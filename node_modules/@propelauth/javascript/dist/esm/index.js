function getOrgHelper(orgIdToOrgMemberInfo) {
  return {
    getOrg(orgId) {
      if (orgIdToOrgMemberInfo.hasOwnProperty(orgId)) {
        return orgIdToOrgMemberInfo[orgId];
      } else {
        return undefined;
      }
    },

    getOrgIds() {
      return Object.keys(orgIdToOrgMemberInfo);
    },

    getOrgs() {
      return Object.values(orgIdToOrgMemberInfo);
    },

    getOrgByName(orgName) {
      for (const orgMemberInfo of Object.values(orgIdToOrgMemberInfo)) {
        if (orgMemberInfo.orgName === orgName || orgMemberInfo.urlSafeOrgName === orgName) {
          return orgMemberInfo;
        }
      }

      return undefined;
    }

  };
}

function getAccessHelper(orgIdToOrgMemberInfo) {
  function isRole(orgId, role) {
    const orgMemberInfo = orgIdToOrgMemberInfo[orgId];

    if (orgMemberInfo === undefined) {
      return false;
    }

    return orgMemberInfo.userAssignedRole === role;
  }

  function isAtLeastRole(orgId, role) {
    const orgMemberInfo = orgIdToOrgMemberInfo[orgId];

    if (orgMemberInfo === undefined) {
      return false;
    }

    return orgMemberInfo.userInheritedRolesPlusCurrentRole.includes(role);
  }

  function hasPermission(orgId, permission) {
    const orgMemberInfo = orgIdToOrgMemberInfo[orgId];

    if (orgMemberInfo === undefined) {
      return false;
    }

    return orgMemberInfo.userPermissions.includes(permission);
  }

  function hasAllPermissions(orgId, permissions) {
    const orgMemberInfo = orgIdToOrgMemberInfo[orgId];

    if (orgMemberInfo === undefined) {
      return false;
    }

    return permissions.every(permission => orgMemberInfo.userPermissions.includes(permission));
  }

  function getAccessHelperWithOrgId(orgId) {
    return {
      isRole(role) {
        return isRole(orgId, role);
      },

      isAtLeastRole(role) {
        return isAtLeastRole(orgId, role);
      },

      hasPermission(permission) {
        return hasPermission(orgId, permission);
      },

      hasAllPermissions(permissions) {
        return hasAllPermissions(orgId, permissions);
      }

    };
  }

  return {
    isRole,
    isAtLeastRole,
    hasPermission,
    hasAllPermissions,
    getAccessHelperWithOrgId
  };
}

function fetchAuthenticationInfo(authUrl) {
  return fetch(`${authUrl}/api/v1/refresh_token`, {
    method: "GET",
    credentials: "include",
    headers: {
      "Content-Type": "application/json"
    }
  }).then(res => {
    if (res.status === 401) {
      return null;
    } else if (res.status === 0) {
      logCorsError();
      return Promise.reject({
        status: 503,
        message: "Unable to process authentication response"
      });
    } else if (!res.ok) {
      return Promise.reject({
        status: res.status,
        message: res.statusText
      });
    } else {
      return parseResponse(res);
    }
  });
}
function logout(authUrl) {
  return fetch(`${authUrl}/api/v1/logout`, {
    method: "POST",
    credentials: "include",
    headers: {
      "Content-Type": "application/json"
    }
  }).then(res => {
    if (res.status === 0) {
      logCorsError();
      return Promise.reject({
        status: 503,
        message: "Unable to process authentication response"
      });
    } else if (!res.ok) {
      console.error("Logout error", res.status, res.statusText);
      return Promise.reject({
        status: res.status,
        message: res.statusText
      });
    } else {
      return res.json();
    }
  });
}

function parseResponse(res) {
  return res.text().then(httpResponse => {
    try {
      return parseJsonConvertingSnakeToCamel(httpResponse);
    } catch (e) {
      console.error("Unable to process authentication response", e);
      return Promise.reject({
        status: 500,
        message: "Unable to process authentication response"
      });
    }
  }, e => {
    console.error("Unable to process authentication response", e);
    return Promise.reject({
      status: 500,
      message: "Unable to process authentication response"
    });
  });
} // The API responds with snake_case, but TypeScript convention is camelCase.
// When parsing JSON, we pass in reviver function to convert from snake_case to camelCase.


function parseJsonConvertingSnakeToCamel(str) {
  return JSON.parse(str, function (key, value) {
    if (key === "org_id") {
      this.orgId = value;
    } else if (key === "org_name") {
      this.orgName = value;
    } else if (key === "url_safe_org_name") {
      this.urlSafeOrgName = value;
    } else if (key === "user_role") {
      this.userAssignedRole = value;
    } else if (key === "inherited_user_roles_plus_current_role") {
      this.userInheritedRolesPlusCurrentRole = value;
    } else if (key === "user_permissions") {
      this.userPermissions = value;
    } else if (key === "access_token") {
      this.accessToken = value;
    } else if (key === "expires_at_seconds") {
      this.expiresAtSeconds = value;
    } else if (key === "org_id_to_org_member_info") {
      this.orgIdToOrgMemberInfo = value;
      this.orgHelper = getOrgHelper(value);
      this.accessHelper = getAccessHelper(value);
    } else if (key === "user_id") {
      this.userId = value;
    } else if (key === "email_confirmed") {
      this.emailConfirmed = value;
    } else if (key === "first_name") {
      this.firstName = value;
    } else if (key === "last_name") {
      this.lastName = value;
    } else if (key === "picture_url") {
      this.pictureUrl = value;
    } else if (key === "mfa_enabled") {
      this.mfaEnabled = value;
    } else if (key === "has_password") {
      this.hasPassword = value;
    } else if (key === "created_at") {
      this.createdAt = value;
    } else if (key === "last_active_at") {
      this.lastActiveAt = value;
    } else if (key === "legacy_user_id") {
      this.legacyUserId = value;
    } else if (key === "impersonator_user") {
      this.impersonatorUserId = value;
    } else {
      return value;
    }
  });
}

function logCorsError() {
  console.error("Request to PropelAuth failed due to a CORS error. There are a few likely causes: \n" + " 1. In the Frontend Integration section of your dashboard, make sure your requests are coming either the specified Application URL or localhost with a matching port.\n" + " 2. Make sure your server is hosted on HTTPS in production.");
}

function currentTimeSeconds() {
  return Date.now() / 1000;
}
function hasLocalStorage() {
  return typeof localStorage !== "undefined";
}
function hasWindow() {
  return typeof window !== "undefined";
}
function getLocalStorageNumber(key) {
  if (!hasLocalStorage()) {
    return null;
  }

  const value = localStorage.getItem(key);

  if (!value) {
    return null;
  }

  const num = parseInt(value, 10);

  if (Number.isNaN(num)) {
    return null;
  }

  return num;
}

const LOGGED_IN_AT_KEY = "__PROPEL_AUTH_LOGGED_IN_AT";
const LOGGED_OUT_AT_KEY = "__PROPEL_AUTH_LOGGED_OUT_AT";
const AUTH_TOKEN_REFRESH_BEFORE_EXPIRATION_SECONDS = 4 * 60;
const DEBOUNCE_DURATION_FOR_REFOCUS_SECONDS = 4 * 60;

function validateAndCleanupOptions(authOptions) {
  try {
    // This helps make sure we have a consistent URL ignoring things like trailing slashes
    const authUrl = new URL(authOptions.authUrl);
    authOptions.authUrl = authUrl.origin;
  } catch (e) {
    console.error("Invalid authUrl", e);
    throw new Error("Unable to initialize auth client");
  }

  if (authOptions.enableBackgroundTokenRefresh === undefined) {
    authOptions.enableBackgroundTokenRefresh = true;
  }
}

function createClient(authOptions) {
  validateAndCleanupOptions(authOptions); // Internal state

  const clientState = {
    initialLoadFinished: false,
    authenticationInfo: null,
    observers: [],
    lastLoggedInAtMessage: getLocalStorageNumber(LOGGED_IN_AT_KEY),
    lastLoggedOutAtMessage: getLocalStorageNumber(LOGGED_OUT_AT_KEY),
    authUrl: authOptions.authUrl,
    refreshInterval: null,
    lastRefresh: null
  }; // Helper functions

  function notifyObservers(isLoggedIn) {
    for (let i = 0; i < clientState.observers.length; i++) {
      const observer = clientState.observers[i];

      if (observer) {
        observer(isLoggedIn);
      }
    }
  }

  function userJustLoggedOut(accessToken, previousAccessToken) {
    // Edge case: the first time we go to the page, if we can't load the
    //   auth token we should treat it as a logout event
    return !accessToken && (previousAccessToken || !clientState.initialLoadFinished);
  }

  function userJustLoggedIn(accessToken, previousAccessToken) {
    return !previousAccessToken && accessToken;
  }

  function updateLastLoggedOutAt() {
    const loggedOutAt = currentTimeSeconds();
    clientState.lastLoggedOutAtMessage = loggedOutAt;

    if (hasLocalStorage()) {
      localStorage.setItem(LOGGED_OUT_AT_KEY, String(loggedOutAt));
    }
  }

  function updateLastLoggedInAt() {
    const loggedInAt = currentTimeSeconds();
    clientState.lastLoggedInAtMessage = loggedInAt;

    if (hasLocalStorage()) {
      localStorage.setItem(LOGGED_IN_AT_KEY, String(loggedInAt));
    }
  }

  function setAuthenticationInfoAndUpdateDownstream(authenticationInfo) {
    var _clientState$authenti;

    const previousAccessToken = (_clientState$authenti = clientState.authenticationInfo) === null || _clientState$authenti === void 0 ? void 0 : _clientState$authenti.accessToken;
    clientState.authenticationInfo = authenticationInfo;
    const accessToken = authenticationInfo === null || authenticationInfo === void 0 ? void 0 : authenticationInfo.accessToken;

    if (userJustLoggedOut(accessToken, previousAccessToken)) {
      notifyObservers(false);
      updateLastLoggedOutAt();
    } else if (userJustLoggedIn(accessToken, previousAccessToken)) {
      notifyObservers(true);
      updateLastLoggedInAt();
    }

    clientState.lastRefresh = currentTimeSeconds();
    clientState.initialLoadFinished = true;
  }

  async function forceRefreshToken(returnCached) {
    try {
      // Happy case, we fetch auth info and save it
      const authenticationInfo = await fetchAuthenticationInfo(clientState.authUrl);
      setAuthenticationInfoAndUpdateDownstream(authenticationInfo);
      return authenticationInfo;
    } catch (e) {
      // If there was an error, we sometimes still want to return the value we have cached
      //   (e.g. if we were prefetching), so in those cases we swallow the exception
      if (returnCached) {
        return clientState.authenticationInfo;
      } else {
        setAuthenticationInfoAndUpdateDownstream(null);
        throw e;
      }
    }
  }

  const getSignupPageUrl = options => {
    let qs = "";

    if (options && options.postSignupRedirectUrl) {
      const encode = window ? window.btoa : btoa;
      qs = new URLSearchParams({
        "rt": encode(options.postSignupRedirectUrl)
      }).toString();
    }

    return `${clientState.authUrl}/signup?${qs}`;
  };

  const getLoginPageUrl = options => {
    let qs = "";

    if (options && options.postLoginRedirectUrl) {
      const encode = window ? window.btoa : btoa;
      qs = new URLSearchParams({
        "rt": encode(options.postLoginRedirectUrl)
      }).toString();
    }

    return `${clientState.authUrl}/login?${qs}`;
  };

  const getAccountPageUrl = () => {
    return `${clientState.authUrl}/account`;
  };

  const getOrgPageUrl = orgId => {
    if (orgId) {
      return `${clientState.authUrl}/org?id=${orgId}`;
    } else {
      return `${clientState.authUrl}/org`;
    }
  };

  const getCreateOrgPageUrl = () => {
    return `${clientState.authUrl}/create_org`;
  };

  const getSetupSAMLPageUrl = orgId => {
    return `${clientState.authUrl}/saml?id=${orgId}`;
  };

  const client = {
    addLoggedInChangeObserver(loggedInChangeObserver) {
      const hasObserver = clientState.observers.includes(loggedInChangeObserver);

      if (hasObserver) {
        console.error("Observer has been attached already.");
      } else if (!loggedInChangeObserver) {
        console.error("Cannot add a null observer");
      } else {
        clientState.observers.push(loggedInChangeObserver);
      }
    },

    removeLoggedInChangeObserver(loggedInChangeObserver) {
      const observerIndex = clientState.observers.indexOf(loggedInChangeObserver);

      if (observerIndex === -1) {
        console.error("Cannot find observer to remove");
      } else {
        clientState.observers.splice(observerIndex, 1);
      }
    },

    async getAuthenticationInfoOrNull(forceRefresh) {
      const currentTimeSecs = currentTimeSeconds();

      if (forceRefresh) {
        return await forceRefreshToken(false);
      } else if (!clientState.authenticationInfo) {
        return await forceRefreshToken(false);
      } else if (currentTimeSecs + AUTH_TOKEN_REFRESH_BEFORE_EXPIRATION_SECONDS > clientState.authenticationInfo.expiresAtSeconds) {
        // Small edge case: If we were being proactive
        //   and the auth information hasn't expired yet, swallow any exceptions
        const returnCached = currentTimeSecs < clientState.authenticationInfo.expiresAtSeconds;
        return await forceRefreshToken(returnCached);
      } else {
        return clientState.authenticationInfo;
      }
    },

    getSignupPageUrl(options) {
      return getSignupPageUrl(options);
    },

    getLoginPageUrl(options) {
      return getLoginPageUrl(options);
    },

    getAccountPageUrl() {
      return getAccountPageUrl();
    },

    getOrgPageUrl(orgId) {
      return getOrgPageUrl(orgId);
    },

    getCreateOrgPageUrl() {
      return getCreateOrgPageUrl();
    },

    getSetupSAMLPageUrl(orgId) {
      return getSetupSAMLPageUrl(orgId);
    },

    redirectToSignupPage(options) {
      window.location.href = getSignupPageUrl(options);
    },

    redirectToLoginPage(options) {
      window.location.href = getLoginPageUrl(options);
    },

    redirectToAccountPage() {
      window.location.href = getAccountPageUrl();
    },

    redirectToOrgPage(orgId) {
      window.location.href = getOrgPageUrl(orgId);
    },

    redirectToCreateOrgPage() {
      window.location.href = getCreateOrgPageUrl();
    },

    redirectToSetupSAMLPage(orgId) {
      window.location.href = getSetupSAMLPageUrl(orgId);
    },

    async logout(redirectAfterLogout) {
      const logoutResponse = await logout(clientState.authUrl);
      setAuthenticationInfoAndUpdateDownstream(null);

      if (redirectAfterLogout) {
        window.location.href = logoutResponse.redirect_to;
      }
    },

    destroy() {
      clientState.observers = [];
      window.removeEventListener("storage", onStorageChange);

      if (clientState.refreshInterval) {
        clearInterval(clientState.refreshInterval);
      }
    }

  };

  const onStorageChange = async function () {
    // If localStorage isn't available, nothing to do here.
    // This usually happens in frameworks that have some SSR components
    if (!hasLocalStorage()) {
      return;
    }

    const loggedOutAt = getLocalStorageNumber(LOGGED_OUT_AT_KEY);
    const loggedInAt = getLocalStorageNumber(LOGGED_IN_AT_KEY); // If we've detected a logout event after the last one our client is aware of, trigger a refresh

    if (loggedOutAt && (!clientState.lastLoggedOutAtMessage || loggedOutAt > clientState.lastLoggedOutAtMessage)) {
      clientState.lastLoggedOutAtMessage = loggedOutAt;

      if (clientState.authenticationInfo) {
        await forceRefreshToken(true);
      }
    } // If we've detected a login event after the last one our client is aware of, trigger a refresh


    if (loggedInAt && (!clientState.lastLoggedInAtMessage || loggedInAt > clientState.lastLoggedInAtMessage)) {
      clientState.lastLoggedInAtMessage = loggedInAt;

      if (!clientState.authenticationInfo) {
        await forceRefreshToken(true);
      }
    }
  }; // If we were offline or on a different tab, when we return, refetch auth info
  // Some browsers trigger focus more often than we'd like, so we'll debounce a little here as well


  const onOnlineOrFocus = async function () {
    if (clientState.lastRefresh && currentTimeSeconds() > clientState.lastRefresh + DEBOUNCE_DURATION_FOR_REFOCUS_SECONDS) {
      await forceRefreshToken(true);
    } else {
      await client.getAuthenticationInfoOrNull();
    }
  };

  if (hasWindow()) {
    window.addEventListener("storage", onStorageChange);
    window.addEventListener("online", onOnlineOrFocus);
    window.addEventListener("focus", onOnlineOrFocus);

    if (authOptions.enableBackgroundTokenRefresh) {
      client.getAuthenticationInfoOrNull();
      clientState.refreshInterval = window.setInterval(client.getAuthenticationInfoOrNull, 60000);
    }
  }

  return client;
}

export { createClient };
//# sourceMappingURL=index.js.map
