{"version":3,"file":"javascript.min.js","sources":["../src/api.ts","../src/org_helper.ts","../src/access_helper.ts","../src/helpers.ts","../src/client.ts"],"sourcesContent":["import {OrgIdToOrgMemberInfo} from \"./org\"\nimport {getOrgHelper, OrgHelper} from \"./org_helper\";\nimport {getAccessHelper, AccessHelper} from \"./access_helper\";\n\nexport type User = {\n    userId: string\n\n    email: string\n    emailConfirmed: boolean,\n\n    hasPassword: boolean,\n\n    username?: string\n    firstName?: string,\n    lastName?: string,\n    pictureUrl?: string,\n\n    locked: boolean,\n    enabled: boolean,\n    mfaEnabled: boolean,\n\n    createdAt: number,\n    lastActiveAt: number,\n\n    legacyUserId?: string\n    properties?: { [key: string]: unknown }\n}\n\nexport type AuthenticationInfo = {\n    accessToken: string\n    expiresAtSeconds: number\n    orgHelper: OrgHelper\n    accessHelper: AccessHelper\n\n    /**\n     * You should prefer orgHelper to orgIdToOrgMemberInfo.\n     * orgHelper provides useful abstractions over this mapping\n     */\n    orgIdToOrgMemberInfo?: OrgIdToOrgMemberInfo\n    user: User\n\n    // If someone on your team is impersonating another user, this will be set to the employee's ID\n    // By default, user impersonation is turned off and this will be undefined\n    impersonatorUserId?: string\n}\n\n\nexport type LogoutResponse = {\n    redirect_to: string\n}\n\nexport function fetchAuthenticationInfo(authUrl: string): Promise<AuthenticationInfo | null> {\n    return fetch(`${authUrl}/api/v1/refresh_token`, {\n        method: \"GET\",\n        credentials: \"include\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n    }).then((res) => {\n        if (res.status === 401) {\n            return null\n        } else if (res.status === 0) {\n            logCorsError()\n            return Promise.reject({\n                status: 503,\n                message: \"Unable to process authentication response\",\n            })\n        } else if (!res.ok) {\n            return Promise.reject({\n                status: res.status,\n                message: res.statusText,\n            })\n        } else {\n            return parseResponse(res)\n        }\n    })\n}\n\nexport function logout(authUrl: string): Promise<LogoutResponse> {\n    return fetch(`${authUrl}/api/v1/logout`, {\n        method: \"POST\",\n        credentials: \"include\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n    }).then((res) => {\n        if (res.status === 0) {\n            logCorsError()\n            return Promise.reject({\n                status: 503,\n                message: \"Unable to process authentication response\",\n            })\n        } else if (!res.ok) {\n            console.error(\"Logout error\", res.status, res.statusText)\n            return Promise.reject({\n                status: res.status,\n                message: res.statusText,\n            })\n        } else {\n            return res.json()\n        }\n    })\n}\n\nfunction parseResponse(res: Response): Promise<AuthenticationInfo> {\n    return res.text().then(httpResponse => {\n        try {\n            return parseJsonConvertingSnakeToCamel(httpResponse)\n        } catch (e) {\n            console.error(\"Unable to process authentication response\", e)\n            return Promise.reject({\n                status: 500,\n                message: \"Unable to process authentication response\",\n            })\n        }\n    }, e => {\n        console.error(\"Unable to process authentication response\", e)\n        return Promise.reject({\n            status: 500,\n            message: \"Unable to process authentication response\",\n        })\n    })\n}\n\n// The API responds with snake_case, but TypeScript convention is camelCase.\n// When parsing JSON, we pass in reviver function to convert from snake_case to camelCase.\nexport function parseJsonConvertingSnakeToCamel(str: string): AuthenticationInfo {\n    return JSON.parse(str, function (key, value) {\n        if (key === \"org_id\") {\n            this.orgId = value\n        } else if (key === \"org_name\") {\n            this.orgName = value\n        } else if (key === \"url_safe_org_name\") {\n            this.urlSafeOrgName = value\n        } else if (key === \"user_role\") {\n            this.userAssignedRole = value\n        } else if (key === \"inherited_user_roles_plus_current_role\") {\n            this.userInheritedRolesPlusCurrentRole = value\n        } else if (key === \"user_permissions\") {\n            this.userPermissions = value\n        } else if (key === \"access_token\") {\n            this.accessToken = value\n        } else if (key === \"expires_at_seconds\") {\n            this.expiresAtSeconds = value\n        } else if (key === \"org_id_to_org_member_info\") {\n            this.orgIdToOrgMemberInfo = value\n            this.orgHelper = getOrgHelper(value)\n            this.accessHelper = getAccessHelper(value)\n        } else if (key === \"user_id\") {\n            this.userId = value\n        } else if (key === \"email_confirmed\") {\n            this.emailConfirmed = value\n        } else if (key === \"first_name\") {\n            this.firstName = value\n        } else if (key === \"last_name\") {\n            this.lastName = value\n        } else if (key === \"picture_url\") {\n            this.pictureUrl = value\n        } else if (key === \"mfa_enabled\") {\n            this.mfaEnabled = value\n        } else if (key === \"has_password\") {\n            this.hasPassword = value\n        } else if (key === \"created_at\") {\n            this.createdAt = value\n        } else if (key === \"last_active_at\") {\n            this.lastActiveAt = value\n        } else if (key === \"legacy_user_id\") {\n            this.legacyUserId = value\n        } else if (key === \"impersonator_user\") {\n            this.impersonatorUserId = value\n        } else {\n            return value\n        }\n    })\n}\n\nfunction logCorsError() {\n    console.error(\n        \"Request to PropelAuth failed due to a CORS error. There are a few likely causes: \\n\" +\n        \" 1. In the Frontend Integration section of your dashboard, make sure your requests are coming either the specified Application URL or localhost with a matching port.\\n\" +\n        \" 2. Make sure your server is hosted on HTTPS in production.\"\n    )\n}","import {OrgIdToOrgMemberInfo, OrgMemberInfo} from \"./org\";\n\nexport type OrgHelper = {\n    getOrgs: () => OrgMemberInfo[]\n    getOrgIds: () => string[]\n    getOrg: (orgId: string) => OrgMemberInfo | undefined\n    getOrgByName: (orgName: string) => OrgMemberInfo | undefined\n}\n\nexport function getOrgHelper(\n    orgIdToOrgMemberInfo: OrgIdToOrgMemberInfo,\n): OrgHelper {\n    return {\n        getOrg(orgId: string): OrgMemberInfo | undefined {\n            if (orgIdToOrgMemberInfo.hasOwnProperty(orgId)) {\n                return orgIdToOrgMemberInfo[orgId]\n            } else {\n                return undefined\n            }\n        },\n        getOrgIds(): string[] {\n            return Object.keys(orgIdToOrgMemberInfo)\n        },\n        getOrgs(): OrgMemberInfo[] {\n            return Object.values(orgIdToOrgMemberInfo)\n        },\n        getOrgByName(orgName: string): OrgMemberInfo | undefined {\n            for (const orgMemberInfo of Object.values(orgIdToOrgMemberInfo)) {\n                if (orgMemberInfo.orgName === orgName || orgMemberInfo.urlSafeOrgName === orgName) {\n                    return orgMemberInfo\n                }\n            }\n            return undefined\n        },\n    }\n}","import {OrgIdToOrgMemberInfo} from \"./org\";\n\nexport type AccessHelper = {\n    isRole: (orgId: string, role: string) => boolean\n    isAtLeastRole: (orgId: string, role: string) => boolean\n    hasPermission: (orgId: string, permission: string) => boolean\n    hasAllPermissions: (orgId: string, permissions: string[]) => boolean\n    getAccessHelperWithOrgId: (orgId: string) => AccessHelperWithOrg\n}\n\nexport type AccessHelperWithOrg = {\n    isRole: (role: string) => boolean\n    isAtLeastRole: (role: string) => boolean\n    hasPermission: (permission: string) => boolean\n    hasAllPermissions: (permissions: string[]) => boolean\n}\n\nexport function getAccessHelper(\n    orgIdToOrgMemberInfo: OrgIdToOrgMemberInfo,\n): AccessHelper {\n    function isRole(orgId: string, role: string): boolean {\n        const orgMemberInfo = orgIdToOrgMemberInfo[orgId]\n        if (orgMemberInfo === undefined) {\n            return false;\n        }\n        return orgMemberInfo.userAssignedRole === role\n    }\n    \n    function isAtLeastRole(orgId: string, role: string): boolean {\n        const orgMemberInfo = orgIdToOrgMemberInfo[orgId]\n        if (orgMemberInfo === undefined) {\n            return false;\n        }\n        return orgMemberInfo.userInheritedRolesPlusCurrentRole.includes(role)\n    }\n\n    function hasPermission(orgId: string, permission: string): boolean {\n        const orgMemberInfo = orgIdToOrgMemberInfo[orgId]\n        if (orgMemberInfo === undefined) {\n            return false;\n        }\n        return orgMemberInfo.userPermissions.includes(permission)\n    }\n\n    function hasAllPermissions(orgId: string, permissions: string[]): boolean {\n        const orgMemberInfo = orgIdToOrgMemberInfo[orgId]\n        if (orgMemberInfo === undefined) {\n            return false;\n        }\n        return permissions.every(permission => orgMemberInfo.userPermissions.includes(permission))\n    }\n\n    function getAccessHelperWithOrgId(orgId: string): AccessHelperWithOrg {\n        return {\n            isRole(role: string): boolean {\n                return isRole(orgId, role)\n            },\n            isAtLeastRole(role: string): boolean {\n                return isAtLeastRole(orgId, role)\n            },\n            hasPermission(permission: string): boolean {\n                return hasPermission(orgId, permission)\n            },\n            hasAllPermissions(permissions: string[]): boolean {\n                return hasAllPermissions(orgId, permissions)\n            },\n        }\n    }\n    \n    return {\n        isRole,\n        isAtLeastRole,\n        hasPermission,\n        hasAllPermissions,\n        getAccessHelperWithOrgId,\n    }\n}\n","export function currentTimeSeconds() {\n    return Date.now() / 1000\n}\n\nexport function hasLocalStorage(): boolean {\n    return typeof localStorage !== \"undefined\"\n}\n\nexport function hasWindow(): boolean {\n    return typeof window !== \"undefined\"\n}\n\nexport function getLocalStorageNumber(key: string): number | null {\n    if (!hasLocalStorage()) {\n        return null\n    }\n\n    const value = localStorage.getItem(key)\n    if (!value) {\n        return null\n    }\n    const num = parseInt(value, 10)\n    if (Number.isNaN(num)) {\n        return null\n    }\n    return num\n}\n","import {AuthenticationInfo, fetchAuthenticationInfo, logout} from \"./api\"\nimport {currentTimeSeconds, getLocalStorageNumber, hasLocalStorage, hasWindow} from \"./helpers\"\n\nconst LOGGED_IN_AT_KEY = \"__PROPEL_AUTH_LOGGED_IN_AT\"\nconst LOGGED_OUT_AT_KEY = \"__PROPEL_AUTH_LOGGED_OUT_AT\"\nconst AUTH_TOKEN_REFRESH_BEFORE_EXPIRATION_SECONDS = 4 * 60\nconst DEBOUNCE_DURATION_FOR_REFOCUS_SECONDS = 4 * 60\n\nexport interface RedirectToSignupOptions {\n    postSignupRedirectUrl: string\n}\n\nexport interface RedirectToLoginOptions {\n    postLoginRedirectUrl: string\n}\n\nexport interface IAuthClient {\n    /**\n     * If the user is logged in, this method returns an access token, the time (in seconds) that the token will expire,\n     * the user's organizations (including org names and user's role within the org), and the user's metadata.\n     * Otherwise, this method returns null.\n     *\n     * The promise will generally resolve immediately, unless our current information is stale in which case it will\n     * make an API request.\n     *\n     * @param forceRefresh If true, this method will always make an API request. Default false\n     */\n    getAuthenticationInfoOrNull(forceRefresh?: boolean): Promise<AuthenticationInfo | null>\n\n    /**\n     * Logs the current user out.\n     * @param redirectAfterLogout If true, will redirect the user to the configured logout URL.\n     */\n    logout(redirectAfterLogout: boolean): Promise<void>\n\n    /**\n     * Gets the URL for the hosted signup page.\n     */\n    getSignupPageUrl(options?: RedirectToSignupOptions): string\n\n    /**\n     * Gets the URL for the hosted login page.\n     */\n    getLoginPageUrl(options?: RedirectToLoginOptions): string\n\n    /**\n     * Gets the URL for the hosted account page.\n     */\n    getAccountPageUrl(): string\n\n    /**\n     * Gets the URL for the hosted organization page.\n     * @param orgId The ID of the organization's page to load. If not specified, a random one will be used instead.\n     */\n    getOrgPageUrl(orgId?: string): string\n\n    /**\n     * Gets the URL for the hosted create organization page.\n     */\n    getCreateOrgPageUrl(): string\n\n    /**\n     * Gets the URL for the hosted SAML configuration page.\n     */\n    getSetupSAMLPageUrl(orgId: string): string\n\n    /**\n     * Redirects the user to the signup page.\n     */\n    redirectToSignupPage(options?: RedirectToSignupOptions): void\n\n    /**\n     * Redirects the user to the login page.\n     */\n    redirectToLoginPage(options?: RedirectToLoginOptions): void\n\n    /**\n     * Redirects the user to the account page.\n     */\n    redirectToAccountPage(): void\n\n    /**\n     * Redirects the user to the organization page.\n     * @param orgId The ID of the organization\"s page to load. If not specified, a random one will be used instead.\n     */\n    redirectToOrgPage(orgId?: string): void\n\n    /**\n     * Redirects the user to the create organization page.\n     */\n    redirectToCreateOrgPage(): void\n\n    /**\n     * Redirects the user to the SAML configuration page.\n     */\n    redirectToSetupSAMLPage(orgId: string): void\n\n\n    /**\n     * Adds an observer which is called whenever the users logs in or logs out.\n     */\n    addLoggedInChangeObserver(observer: (isLoggedIn: boolean) => void): void\n\n    /**\n     * Removes the observer\n     */\n    removeLoggedInChangeObserver(observer: (isLoggedIn: boolean) => void): void\n\n    /**\n     * Cleanup the auth client if you no longer need it.\n     */\n    destroy(): void\n}\n\nexport interface IAuthOptions {\n    /**\n     * Base URL where your authentication pages are hosted. See **Frontend Integration** section of your PropelAuth project.\n     */\n    authUrl: string\n\n    /**\n     * If true, periodically refresh the token in the background.\n     * This helps ensure you always have a valid token ready to go when you need it.\n     *\n     * Default true\n     */\n    enableBackgroundTokenRefresh?: boolean\n}\n\ninterface ClientState {\n    initialLoadFinished: boolean\n    authenticationInfo: AuthenticationInfo | null\n    observers: ((isLoggedIn: boolean) => void)[]\n    lastLoggedInAtMessage: number | null\n    lastLoggedOutAtMessage: number | null\n    refreshInterval: number | null\n    lastRefresh: number | null\n    readonly authUrl: string\n}\n\nfunction validateAndCleanupOptions(authOptions: IAuthOptions) {\n    try {\n        // This helps make sure we have a consistent URL ignoring things like trailing slashes\n        const authUrl = new URL(authOptions.authUrl)\n        authOptions.authUrl = authUrl.origin\n    } catch (e) {\n        console.error(\"Invalid authUrl\", e)\n        throw new Error(\"Unable to initialize auth client\")\n    }\n\n    if (authOptions.enableBackgroundTokenRefresh === undefined) {\n        authOptions.enableBackgroundTokenRefresh = true\n    }\n}\n\nexport function createClient(authOptions: IAuthOptions): IAuthClient {\n    validateAndCleanupOptions(authOptions)\n\n    // Internal state\n    const clientState: ClientState = {\n        initialLoadFinished: false,\n        authenticationInfo: null,\n        observers: [],\n        lastLoggedInAtMessage: getLocalStorageNumber(LOGGED_IN_AT_KEY),\n        lastLoggedOutAtMessage: getLocalStorageNumber(LOGGED_OUT_AT_KEY),\n        authUrl: authOptions.authUrl,\n        refreshInterval: null,\n        lastRefresh: null,\n    }\n\n    // Helper functions\n    function notifyObservers(isLoggedIn: boolean) {\n        for (let i = 0; i < clientState.observers.length; i++) {\n            const observer = clientState.observers[i]\n            if (observer) {\n                observer(isLoggedIn)\n            }\n        }\n    }\n\n    function userJustLoggedOut(accessToken: string | undefined, previousAccessToken: string | undefined) {\n        // Edge case: the first time we go to the page, if we can't load the\n        //   auth token we should treat it as a logout event\n        return !accessToken && (previousAccessToken || !clientState.initialLoadFinished)\n    }\n\n    function userJustLoggedIn(accessToken: string | undefined, previousAccessToken: string | undefined) {\n        return !previousAccessToken && accessToken\n    }\n\n    function updateLastLoggedOutAt() {\n        const loggedOutAt = currentTimeSeconds()\n        clientState.lastLoggedOutAtMessage = loggedOutAt\n        if (hasLocalStorage()) {\n            localStorage.setItem(LOGGED_OUT_AT_KEY, String(loggedOutAt))\n        }\n    }\n\n    function updateLastLoggedInAt() {\n        const loggedInAt = currentTimeSeconds()\n        clientState.lastLoggedInAtMessage = loggedInAt\n        if (hasLocalStorage()) {\n            localStorage.setItem(LOGGED_IN_AT_KEY, String(loggedInAt))\n        }\n    }\n\n    function setAuthenticationInfoAndUpdateDownstream(authenticationInfo: AuthenticationInfo | null) {\n        const previousAccessToken = clientState.authenticationInfo?.accessToken\n        clientState.authenticationInfo = authenticationInfo\n        const accessToken = authenticationInfo?.accessToken\n\n        if (userJustLoggedOut(accessToken, previousAccessToken)) {\n            notifyObservers(false)\n            updateLastLoggedOutAt()\n        } else if (userJustLoggedIn(accessToken, previousAccessToken)) {\n            notifyObservers(true)\n            updateLastLoggedInAt()\n        }\n\n        clientState.lastRefresh = currentTimeSeconds()\n        clientState.initialLoadFinished = true\n    }\n\n    async function forceRefreshToken(returnCached: boolean): Promise<AuthenticationInfo | null> {\n        try {\n            // Happy case, we fetch auth info and save it\n            const authenticationInfo = await fetchAuthenticationInfo(clientState.authUrl)\n            setAuthenticationInfoAndUpdateDownstream(authenticationInfo)\n            return authenticationInfo\n        } catch (e) {\n            // If there was an error, we sometimes still want to return the value we have cached\n            //   (e.g. if we were prefetching), so in those cases we swallow the exception\n            if (returnCached) {\n                return clientState.authenticationInfo\n            } else {\n                setAuthenticationInfoAndUpdateDownstream(null)\n                throw e\n            }\n        }\n    }\n\n    const getSignupPageUrl = (options?: RedirectToSignupOptions) => {\n        let qs = \"\"\n        if (options && options.postSignupRedirectUrl) {\n            const encode = window ? window.btoa : btoa;\n            qs = new URLSearchParams({\"rt\": encode(options.postSignupRedirectUrl)}).toString()\n        }\n        return `${clientState.authUrl}/signup?${qs}`\n    }\n\n    const getLoginPageUrl = (options?: RedirectToLoginOptions) => {\n        let qs = \"\"\n        if (options && options.postLoginRedirectUrl) {\n            const encode = window ? window.btoa : btoa;\n            qs = new URLSearchParams({\"rt\": encode(options.postLoginRedirectUrl)}).toString()\n        }\n        return `${clientState.authUrl}/login?${qs}`\n    }\n\n    const getAccountPageUrl = () => {\n        return `${clientState.authUrl}/account`\n    }\n\n    const getOrgPageUrl = (orgId?: string) => {\n        if (orgId) {\n            return `${clientState.authUrl}/org?id=${orgId}`\n        } else {\n            return `${clientState.authUrl}/org`\n        }\n    }\n\n    const getCreateOrgPageUrl = () => {\n        return `${clientState.authUrl}/create_org`\n    }\n\n    const getSetupSAMLPageUrl = (orgId: string) => {\n        return `${clientState.authUrl}/saml?id=${orgId}`\n    }\n\n    const client = {\n        addLoggedInChangeObserver(loggedInChangeObserver: (isLoggedIn: boolean) => void): void {\n            const hasObserver = clientState.observers.includes(loggedInChangeObserver)\n            if (hasObserver) {\n                console.error(\"Observer has been attached already.\")\n            } else if (!loggedInChangeObserver) {\n                console.error(\"Cannot add a null observer\")\n            } else {\n                clientState.observers.push(loggedInChangeObserver)\n            }\n        },\n\n        removeLoggedInChangeObserver(loggedInChangeObserver: (isLoggedIn: boolean) => void): void {\n            const observerIndex = clientState.observers.indexOf(loggedInChangeObserver)\n            if (observerIndex === -1) {\n                console.error(\"Cannot find observer to remove\")\n            } else {\n                clientState.observers.splice(observerIndex, 1)\n            }\n        },\n\n        async getAuthenticationInfoOrNull(forceRefresh?: boolean): Promise<AuthenticationInfo | null> {\n            const currentTimeSecs = currentTimeSeconds()\n            if (forceRefresh) {\n                return await forceRefreshToken(false)\n            } else if (!clientState.authenticationInfo) {\n                return await forceRefreshToken(false)\n            } else if (\n                currentTimeSecs + AUTH_TOKEN_REFRESH_BEFORE_EXPIRATION_SECONDS >\n                clientState.authenticationInfo.expiresAtSeconds\n            ) {\n                // Small edge case: If we were being proactive\n                //   and the auth information hasn't expired yet, swallow any exceptions\n                const returnCached = currentTimeSecs < clientState.authenticationInfo.expiresAtSeconds\n                return await forceRefreshToken(returnCached)\n            } else {\n                return clientState.authenticationInfo\n            }\n        },\n\n        getSignupPageUrl(options?: RedirectToSignupOptions): string {\n            return getSignupPageUrl(options)\n        },\n\n        getLoginPageUrl(options?: RedirectToLoginOptions): string {\n            return getLoginPageUrl(options)\n        },\n\n        getAccountPageUrl(): string {\n            return getAccountPageUrl()\n        },\n\n        getOrgPageUrl(orgId?: string): string {\n            return getOrgPageUrl(orgId)\n        },\n\n        getCreateOrgPageUrl(): string {\n            return getCreateOrgPageUrl()\n        },\n\n        getSetupSAMLPageUrl(orgId: string): string {\n            return getSetupSAMLPageUrl(orgId)\n        },\n\n        redirectToSignupPage(options?: RedirectToSignupOptions): void {\n            window.location.href = getSignupPageUrl(options)\n        },\n\n        redirectToLoginPage(options?: RedirectToLoginOptions): void {\n            window.location.href = getLoginPageUrl(options)\n        },\n\n        redirectToAccountPage(): void {\n            window.location.href = getAccountPageUrl()\n        },\n\n        redirectToOrgPage(orgId?: string): void {\n            window.location.href = getOrgPageUrl(orgId)\n        },\n\n        redirectToCreateOrgPage(): void {\n            window.location.href = getCreateOrgPageUrl()\n        },\n\n        redirectToSetupSAMLPage(orgId: string) {\n            window.location.href = getSetupSAMLPageUrl(orgId)\n        },\n\n        async logout(redirectAfterLogout: boolean): Promise<void> {\n            const logoutResponse = await logout(clientState.authUrl)\n            setAuthenticationInfoAndUpdateDownstream(null)\n            if (redirectAfterLogout) {\n                window.location.href = logoutResponse.redirect_to\n            }\n        },\n\n        destroy() {\n            clientState.observers = []\n            window.removeEventListener(\"storage\", onStorageChange)\n            if (clientState.refreshInterval) {\n                clearInterval(clientState.refreshInterval)\n            }\n        },\n    }\n\n    const onStorageChange = async function () {\n        // If localStorage isn't available, nothing to do here.\n        // This usually happens in frameworks that have some SSR components\n        if (!hasLocalStorage()) {\n            return\n        }\n\n        const loggedOutAt = getLocalStorageNumber(LOGGED_OUT_AT_KEY)\n        const loggedInAt = getLocalStorageNumber(LOGGED_IN_AT_KEY)\n\n        // If we've detected a logout event after the last one our client is aware of, trigger a refresh\n        if (loggedOutAt && (!clientState.lastLoggedOutAtMessage || loggedOutAt > clientState.lastLoggedOutAtMessage)) {\n            clientState.lastLoggedOutAtMessage = loggedOutAt\n            if (clientState.authenticationInfo) {\n                await forceRefreshToken(true)\n            }\n        }\n\n        // If we've detected a login event after the last one our client is aware of, trigger a refresh\n        if (loggedInAt && (!clientState.lastLoggedInAtMessage || loggedInAt > clientState.lastLoggedInAtMessage)) {\n            clientState.lastLoggedInAtMessage = loggedInAt\n            if (!clientState.authenticationInfo) {\n                await forceRefreshToken(true)\n            }\n        }\n    }\n\n    // If we were offline or on a different tab, when we return, refetch auth info\n    // Some browsers trigger focus more often than we'd like, so we'll debounce a little here as well\n    const onOnlineOrFocus = async function () {\n        if (clientState.lastRefresh && currentTimeSeconds() > clientState.lastRefresh + DEBOUNCE_DURATION_FOR_REFOCUS_SECONDS) {\n            await forceRefreshToken(true)\n        } else {\n            await client.getAuthenticationInfoOrNull()\n        }\n    }\n\n    if (hasWindow()) {\n        window.addEventListener(\"storage\", onStorageChange)\n        window.addEventListener(\"online\", onOnlineOrFocus)\n        window.addEventListener(\"focus\", onOnlineOrFocus)\n\n        if (authOptions.enableBackgroundTokenRefresh) {\n            client.getAuthenticationInfoOrNull()\n            clientState.refreshInterval = window.setInterval(client.getAuthenticationInfoOrNull, 60000)\n        }\n    }\n\n    return client\n}\n"],"names":["fetchAuthenticationInfo","authUrl","fetch","method","credentials","headers","then","res","status","logCorsError","Promise","reject","message","ok","text","httpResponse","str","JSON","parse","key","value","orgId","orgName","urlSafeOrgName","userAssignedRole","userInheritedRolesPlusCurrentRole","userPermissions","accessToken","expiresAtSeconds","orgIdToOrgMemberInfo","orgHelper","getOrg","hasOwnProperty","getOrgIds","Object","keys","getOrgs","values","getOrgByName","orgMemberInfo","accessHelper","isRole","role","undefined","isAtLeastRole","includes","hasPermission","permission","hasAllPermissions","permissions","every","getAccessHelperWithOrgId","getAccessHelper","userId","emailConfirmed","firstName","lastName","pictureUrl","mfaEnabled","hasPassword","createdAt","lastActiveAt","legacyUserId","impersonatorUserId","e","console","error","parseResponse","statusText","currentTimeSeconds","Date","now","hasLocalStorage","localStorage","getLocalStorageNumber","getItem","num","parseInt","Number","isNaN","LOGGED_IN_AT_KEY","LOGGED_OUT_AT_KEY","authOptions","URL","origin","Error","enableBackgroundTokenRefresh","validateAndCleanupOptions","clientState","initialLoadFinished","authenticationInfo","observers","lastLoggedInAtMessage","lastLoggedOutAtMessage","refreshInterval","lastRefresh","notifyObservers","isLoggedIn","i","length","observer","setAuthenticationInfoAndUpdateDownstream","previousAccessToken","_clientState$authenti","userJustLoggedOut","userJustLoggedIn","loggedInAt","setItem","String","updateLastLoggedInAt","loggedOutAt","updateLastLoggedOutAt","forceRefreshToken","returnCached","getSignupPageUrl","options","qs","postSignupRedirectUrl","encode","window","btoa","URLSearchParams","toString","getLoginPageUrl","postLoginRedirectUrl","getAccountPageUrl","getOrgPageUrl","getCreateOrgPageUrl","getSetupSAMLPageUrl","client","addLoggedInChangeObserver","loggedInChangeObserver","push","removeLoggedInChangeObserver","observerIndex","indexOf","splice","forceRefresh","currentTimeSecs","redirectToSignupPage","location","href","redirectToLoginPage","redirectToAccountPage","redirectToOrgPage","redirectToCreateOrgPage","redirectToSetupSAMLPage","redirectAfterLogout","logoutResponse","json","redirect_to","destroy","removeEventListener","onStorageChange","clearInterval","async","onOnlineOrFocus","getAuthenticationInfoOrNull","addEventListener","setInterval"],"mappings":"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"}